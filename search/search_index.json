{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2728 The little ASGI framework that shines. \u2728 Introduction Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn Example from starlette.applications import Starlette from starlette.responses import JSONResponse import uvicorn app = Starlette () @app.route ( '/' ) async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) if __name__ == '__main__' : uvicorn . run ( app , host = '0.0.0.0' , port = 8000 ) Dependencies Starlette does not have any hard dependencies, but the following are optional: [requests][requests] - Required if you want to use the TestClient . [aiofiles][aiofiles] - Required if you want to use FileResponse or StaticFiles . [python-multipart][python-multipart] - Required if you want to support form parsing, with request.form() . [graphene][graphene] - Required for GraphQL support. [itsdangerous][itsdangerous] - Required for SessionMiddleware support. [ujson][ujson] - Required if you want to use UJSONResponse . You can install all of these with pip3 install starlette[full] . Framework or Toolkit Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) Run the App application in example.py : $ uvicorn example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) Modularity The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation. Performance Our testing shows that Starlette applications running under Uvicorn as one of the fastest Python frameworks available. As an example, application performance should roughly equal or out-perform Sanic. For high throughput loads you should: Make sure to install ujson and use UJSONResponse . Run using uvicorn , with access logging disabled. Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Eg. uvicorn.run(..., http='h11', loop='asyncio') \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#introduction","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. It is production-ready, and gives you the following: Seriously impressive performance. WebSocket support. GraphQL support. In-process background tasks. Startup and shutdown events. Test client built on requests . CORS, GZip, Static Files, Streaming responses. Session and Cookie support. 100% test coverage. 100% type annotated codebase. Zero hard dependencies.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install starlette You'll also want to install an ASGI server, such as uvicorn , daphne , or hypercorn . $ pip3 install uvicorn","title":"Installation"},{"location":"#example","text":"from starlette.applications import Starlette from starlette.responses import JSONResponse import uvicorn app = Starlette () @app.route ( '/' ) async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) if __name__ == '__main__' : uvicorn . run ( app , host = '0.0.0.0' , port = 8000 )","title":"Example"},{"location":"#dependencies","text":"Starlette does not have any hard dependencies, but the following are optional: [requests][requests] - Required if you want to use the TestClient . [aiofiles][aiofiles] - Required if you want to use FileResponse or StaticFiles . [python-multipart][python-multipart] - Required if you want to support form parsing, with request.form() . [graphene][graphene] - Required for GraphQL support. [itsdangerous][itsdangerous] - Required for SessionMiddleware support. [ujson][ujson] - Required if you want to use UJSONResponse . You can install all of these with pip3 install starlette[full] .","title":"Dependencies"},{"location":"#framework-or-toolkit","text":"Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) Run the App application in example.py : $ uvicorn example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit )","title":"Framework or Toolkit"},{"location":"#modularity","text":"The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications. The clean API separation also means it's easier to understand each component in isolation.","title":"Modularity"},{"location":"#performance","text":"Our testing shows that Starlette applications running under Uvicorn as one of the fastest Python frameworks available. As an example, application performance should roughly equal or out-perform Sanic. For high throughput loads you should: Make sure to install ujson and use UJSONResponse . Run using uvicorn , with access logging disabled. Several of the ASGI servers also have pure Python implementations available, so you can also run under PyPy if your application code has parts that are CPU constrained. Eg. uvicorn.run(..., http='h11', loop='asyncio') \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Performance"},{"location":"applications/","text":"Starlette includes an application class Starlette that nicely ties together all of its other functionality. from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.staticfiles import StaticFiles app = Starlette () app . debug = True app . mount ( '/static' , StaticFiles ( directory = \"static\" )) @app.route ( '/' ) def homepage ( request ): return PlainTextResponse ( 'Hello, world!' ) @app.route ( '/user/{username}' ) def user ( request ): username = request . path_params [ 'username' ] return PlainTextResponse ( 'Hello, %s !' % username ) @app.websocket_route ( '/ws' ) async def websocket_endpoint ( websocket ): await websocket . accept () await websocket . send_text ( 'Hello, websocket!' ) await websocket . close () @app.on_event ( 'startup' ) def startup (): print ( 'Ready to go' ) Instantiating the application Starlette(debug=False) - Create a new Starlette application. Adding routes to the application You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . app.add_graphql_route(path, schema, executor=None) - Add a GraphQL route. @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style. Adding event handlers to the application There are two ways to add event handlers: @app.on_event(event_type) - Add an event, decorator style app.add_event_handler(event_type, func) - Add an event through a function call. event_type must be specified as either 'startup' or 'shutdown' . Submounting other applications Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix Customizing exception handling You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Applications"},{"location":"applications/#instantiating-the-application","text":"Starlette(debug=False) - Create a new Starlette application.","title":"Instantiating the application"},{"location":"applications/#adding-routes-to-the-application","text":"You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . app.add_graphql_route(path, schema, executor=None) - Add a GraphQL route. @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style.","title":"Adding routes to the application"},{"location":"applications/#adding-event-handlers-to-the-application","text":"There are two ways to add event handlers: @app.on_event(event_type) - Add an event, decorator style app.add_event_handler(event_type, func) - Add an event through a function call. event_type must be specified as either 'startup' or 'shutdown' .","title":"Adding event handlers to the application"},{"location":"applications/#submounting-other-applications","text":"Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix","title":"Submounting other applications"},{"location":"applications/#customizing-exception-handling","text":"You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Customizing exception handling"},{"location":"background/","text":"Starlette includes a BackgroundTask class for in-process background tasks. A background task should be attached to a response, and will run only once the response has been sent. Background Task Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTask app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ...","title":"Background Tasks"},{"location":"background/#background-task","text":"Signature: BackgroundTask(func, *args, **kwargs) from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.background import BackgroundTask app = Starlette () @app.route ( '/user/signup' , methods = [ 'POST' ]) async def signup ( request ): data = await request . json () username = data [ 'username' ] email = data [ 'email' ] task = BackgroundTask ( send_welcome_email , to_address = email ) message = { 'status' : 'Signup successful' } return JSONResponse ( message , background = task ) async def send_welcome_email ( to_address ): ...","title":"Background Task"},{"location":"debug/","text":"You can use Starlette's DebugMiddleware to display simple error tracebacks in the browser. from starlette.debug import DebugMiddleware class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): raise RuntimeError ( 'Something went wrong' ) app = DebugMiddleware ( App ) For a more complete handling of exception cases you may wish to use Starlette's ExceptionMiddleware class instead, which also includes optional debug handling.","title":"Debug"},{"location":"endpoints/","text":"Starlette includes the classes HTTPEndpoint and WebSocketEndpoint that provide a class-based view pattern for handling HTTP method dispatching and WebSocket sessions. HTTPEndpoint The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class by using the @app.route() decorator, or the app.add_route() function. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint app = Starlette () @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) @app.route ( \"/{username}\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, {username}\" ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler. WebSocketEndpoint The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse app = Starlette () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) @app.websocket_route ( \"/ws\" ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: {data}\" ) if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 )","title":"Endpoints"},{"location":"endpoints/#httpendpoint","text":"The HTTPEndpoint class can be used as an ASGI application: from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint class App ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to an HTTPEndpoint class by using the @app.route() decorator, or the app.add_route() function. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.applications import Starlette from starlette.responses import PlainTextResponse from starlette.endpoints import HTTPEndpoint app = Starlette () @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) @app.route ( \"/{username}\" ) class User ( HTTPEndpoint ): async def get ( self , request ): username = request . path_params [ 'username' ] return PlainTextResponse ( f \"Hello, {username}\" ) HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.","title":"HTTPEndpoint"},{"location":"endpoints/#websocketendpoint","text":"The WebSocketEndpoint class is an ASGI application that presents a wrapper around the functionality of a WebSocket instance. The ASGI connection scope is accessible on the endpoint instance via .scope and has an attribute encoding which may optionally be set, in order to validate the expected websocket data in the on_receive method. The encoding types are: 'json' 'bytes' 'text' There are three overridable methods for handling specific ASGI websocket message types: async def on_connect(websocket, **kwargs) async def on_receive(websocket, data) async def on_disconnect(websocket, close_code) from starlette.endpoints import WebSocketEndpoint class App ( WebSocketEndpoint ): encoding = 'bytes' async def on_connect ( self , websocket ): await websocket . accept () async def on_receive ( self , websocket , data ): await websocket . send_bytes ( b \"Message: \" + data ) async def on_disconnect ( self , websocket , close_code ): pass The WebSocketEndpoint can also be used with the Starlette application class: import uvicorn from starlette.applications import Starlette from starlette.endpoints import WebSocketEndpoint , HTTPEndpoint from starlette.responses import HTMLResponse app = Starlette () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Chat</title> </head> <body> <h1>WebSocket Chat</h1> <form action=\"\" onsubmit=\"sendMessage(event)\"> <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/> <button>Send</button> </form> <ul id='messages'> </ul> <script> var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } </script> </body> </html> \"\"\" @app.route ( \"/\" ) class Homepage ( HTTPEndpoint ): async def get ( self , request ): return HTMLResponse ( html ) @app.websocket_route ( \"/ws\" ) class Echo ( WebSocketEndpoint ): encoding = \"text\" async def on_receive ( self , websocket , data ): await websocket . send_text ( f \"Message text was: {data}\" ) if __name__ == \"__main__\" : uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 )","title":"WebSocketEndpoint"},{"location":"events/","text":"Starlette applications can register multiple event handlers for dealing with code that needs to run before the application starts up, or when the application is shutting down. Registering events These event handlers can either be async coroutines, or regular syncronous functions. The event handlers can be registered with a decorator syntax, like so: from starlette.applications import Starlette app = Starlette () @app.on_event ( 'startup' ) async def open_database_connection_pool (): ... @app.on_event ( 'shutdown' ) async def close_database_connection_pool (): ... Or as a regular function call: from starlette.applications import Starlette app = Starlette () async def open_database_connection_pool (): ... async def close_database_connection_pool (): ... app . add_event_handler ( 'startup' , open_database_connection_pool ) app . add_event_handler ( 'shutdown' , close_database_connection_pool ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. Note : The ASGI lifespan protocol has only recently been added to the spec, and is only currently supported by the uvicorn server. Make sure to use the latest uvicorn release if you need startup/cleanup support. Running event handers in tests You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, Starlette provides a context manager that ensures the lifespan events are called. from example import app from starlette.lifespan import LifespanContext from starlette.testclient import TestClient def test_homepage (): with LifespanContext ( app ): # Application 'startup' handlers are called on entering the block. client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'shutdown' handlers are called on exiting the block.","title":"Events"},{"location":"events/#registering-events","text":"These event handlers can either be async coroutines, or regular syncronous functions. The event handlers can be registered with a decorator syntax, like so: from starlette.applications import Starlette app = Starlette () @app.on_event ( 'startup' ) async def open_database_connection_pool (): ... @app.on_event ( 'shutdown' ) async def close_database_connection_pool (): ... Or as a regular function call: from starlette.applications import Starlette app = Starlette () async def open_database_connection_pool (): ... async def close_database_connection_pool (): ... app . add_event_handler ( 'startup' , open_database_connection_pool ) app . add_event_handler ( 'shutdown' , close_database_connection_pool ) Starlette will not start serving any incoming requests until all of the registered startup handlers have completed. The shutdown handlers will run once all connections have been closed, and any in-process background tasks have completed. Note : The ASGI lifespan protocol has only recently been added to the spec, and is only currently supported by the uvicorn server. Make sure to use the latest uvicorn release if you need startup/cleanup support.","title":"Registering events"},{"location":"events/#running-event-handers-in-tests","text":"You might want to explicitly call into your event handlers in any test setup or test teardown code. Alternatively, Starlette provides a context manager that ensures the lifespan events are called. from example import app from starlette.lifespan import LifespanContext from starlette.testclient import TestClient def test_homepage (): with LifespanContext ( app ): # Application 'startup' handlers are called on entering the block. client = TestClient ( app ) response = client . get ( \"/\" ) assert response . status_code == 200 # Application 'shutdown' handlers are called on exiting the block.","title":"Running event handers in tests"},{"location":"exceptions/","text":"Starlette includes an exception handling middleware that you can use in order to dispatch different classes of exceptions to different handlers. To see how this works, we'll start by with this small ASGI application: from starlette.exceptions import ExceptionMiddleware , HTTPException class App : def __init__ ( self , scope ): raise HTTPException ( status_code = 403 ) app = ExceptionMiddleware ( App ) If you run the app and make an HTTP request to it, you'll get a plain text response with a \"403 Permission Denied\" response. This is the behaviour that the default handler responds with when an HTTPException class or subclass is raised. Let's change the exception handling, so that we get JSON error responses instead: from starlette.exceptions import ExceptionMiddleware , HTTPException from starlette.responses import JSONResponse class App : def __init__ ( self , scope ): raise HTTPException ( status_code = 403 ) def handler ( request , exc ): return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) app = ExceptionMiddleware ( App ) app . add_exception_handler ( HTTPException , handler ) Now if we make a request to the application, we'll get back a JSON encoded HTTP response. By default two types of exceptions are caught and dealt with: HTTPException - Used to raise standard HTTP error codes. Exception - Used as a catch-all handler to deal with any 500 Internal Server Error responses. The Exception case also wraps any other exception handling. The catch-all Exception case is used to return simple 500 Internal Server Error responses. During development you might want to switch the behaviour so that it displays an error traceback in the browser: app = ExceptionMiddleware(App, debug=True) This uses the same error tracebacks as the more minimal DebugMiddleware . The exception handler currently only catches and deals with exceptions within HTTP requests. Any websocket exceptions will simply be raised to the server and result in an error log. ExceptionMiddleware The exception middleware catches and handles the exceptions, returning appropriate HTTP responses. ExceptionMiddleware(app, debug=False) - Instantiate the exception handler, wrapping up it around an inner ASGI application. Adding handlers: .add_exception_handler(exc_class, handler) - Set a handler function to run for the given exception class. Enabling debug mode: .debug - If set to True , then the catch-all handler for Exception will not be used, and error tracebacks will be sent as responses instead. HTTPException The HTTPException class provides a base class that you can use for any standard HTTP error conditions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None)","title":"Exceptions"},{"location":"exceptions/#exceptionmiddleware","text":"The exception middleware catches and handles the exceptions, returning appropriate HTTP responses. ExceptionMiddleware(app, debug=False) - Instantiate the exception handler, wrapping up it around an inner ASGI application. Adding handlers: .add_exception_handler(exc_class, handler) - Set a handler function to run for the given exception class. Enabling debug mode: .debug - If set to True , then the catch-all handler for Exception will not be used, and error tracebacks will be sent as responses instead.","title":"ExceptionMiddleware"},{"location":"exceptions/#httpexception","text":"The HTTPException class provides a base class that you can use for any standard HTTP error conditions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None)","title":"HTTPException"},{"location":"graphql/","text":"Starlette includes optional support for GraphQL, using the graphene library. Here's an example of integrating the support into your application. from starlette.applications import Starlette import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) def resolve_hello ( self , info , name ): return \"Hello \" + name app = Starlette () app . add_graphql_route ( '/' , schema = graphene . Schema ( query = Query )) If you load up the page in a browser, you'll be served the GraphiQL tool, which you can use to interact with your GraphQL API. Sync or Async executors If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a seperate thread. If you want to use an asyncronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name app = Starlette () # We're using `executor=AsyncioExecutor()` here. app . add_graphql_route ( '/' , schema = graphene . Schema ( query = Query ), executor = AsyncioExecutor ())","title":"GraphQL"},{"location":"graphql/#sync-or-async-executors","text":"If you're working with a standard ORM, then just use regular function calls for your \"resolve\" methods, and Starlette will manage running the GraphQL query within a seperate thread. If you want to use an asyncronous ORM, then use \"async resolve\" methods, and make sure to setup Graphene's AsyncioExecutor using the executor argument. from graphql.execution.executors.asyncio import AsyncioExecutor from starlette.applications import Starlette import graphene class Query ( graphene . ObjectType ): hello = graphene . String ( name = graphene . String ( default_value = \"stranger\" )) async def resolve_hello ( self , info , name ): # We can make asynchronous network calls here. return \"Hello \" + name app = Starlette () # We're using `executor=AsyncioExecutor()` here. app . add_graphql_route ( '/' , schema = graphene . Schema ( query = Query ), executor = AsyncioExecutor ())","title":"Sync or Async executors"},{"location":"middleware/","text":"Starlette includes several middleware classes for adding behaviour that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Starlette or to any other ASGI application. The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () # Ensure that all requests include an 'example.com' or '*.example.com' host header, # and strictly enforce https-only access. app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) app . add_middleware ( HTTPSRedirectMiddleware ) The following middleware implementations are available in the Starlette package: CORSMiddleware Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware.cors import CORSMiddleware app = Starlette () app . add_middleware ( CORSMiddleware , allow_origins = [ '*' ]) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 60 . The middleware responds to two particular types of HTTP request... CORS preflight requests These are any OPTION request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. Simple requests Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. SessionMiddleware Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\". HTTPSRedirectMiddleware Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware app = Starlette () app . add_middleware ( HTTPSRedirectMiddleware ) There are no configuration options for this middleware class. TrustedHostMiddleware Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware.gzip import GZipMiddleware app = Starlette () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 . Using ASGI middleware without Starlette To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use .add_middleware , as it'll ensure that you don't lose the reference to the application object, and that the exception handling always wraps around any other behaviour. BaseHTTPMiddleware An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the class if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): self . app = app self . header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance.","title":"Middleware"},{"location":"middleware/#corsmiddleware","text":"Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers. The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. from starlette.applications import Starlette from starlette.middleware.cors import CORSMiddleware app = Starlette () app . add_middleware ( CORSMiddleware , allow_origins = [ '*' ]) The following arguments are supported: allow_origins - A list of origins that should be permitted to make cross-origin requests. eg. ['https://example.org', 'https://www.example.org'] . You can use ['*'] to allow any origin. allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. eg. 'https://.*\\.example\\.org' . allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET'] . You can use ['*'] to allow all standard methods. allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to [] . You can use ['*'] to allow all headers. The Accept , Accept-Language , Content-Language and Content-Type headers are always allowed for CORS requests. allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False . expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [] . max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 60 . The middleware responds to two particular types of HTTP request...","title":"CORSMiddleware"},{"location":"middleware/#cors-preflight-requests","text":"These are any OPTION request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.","title":"CORS preflight requests"},{"location":"middleware/#simple-requests","text":"Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.","title":"Simple requests"},{"location":"middleware/#sessionmiddleware","text":"Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable. Access or modify the session data using the request.session dictionary interface. The following arguments are supported: secret_key - Should be a random string. session_cookie - Defaults to \"session\".","title":"SessionMiddleware"},{"location":"middleware/#httpsredirectmiddleware","text":"Enforces that all incoming requests must either be https or wss . Any incoming requests to http or ws will be redirected to the secure scheme instead. from starlette.applications import Starlette from starlette.middleware.httpsredirect import HTTPSRedirectMiddleware app = Starlette () app . add_middleware ( HTTPSRedirectMiddleware ) There are no configuration options for this middleware class.","title":"HTTPSRedirectMiddleware"},{"location":"middleware/#trustedhostmiddleware","text":"Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from starlette.applications import Starlette from starlette.middleware.trustedhost import TrustedHostMiddleware app = Starlette () app . add_middleware ( TrustedHostMiddleware , allowed_hosts = [ 'example.com' , '*.example.com' ]) The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent.","title":"TrustedHostMiddleware"},{"location":"middleware/#gzipmiddleware","text":"Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from starlette.applications import Starlette from starlette.middleware.gzip import GZipMiddleware app = Starlette () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500 .","title":"GZipMiddleware"},{"location":"middleware/#using-asgi-middleware-without-starlette","text":"To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance: app = TrustedHostMiddleware ( app , allowed_hosts = [ 'example.com' ]) You can do this with a Starlette application instance too, but it is preferable to use .add_middleware , as it'll ensure that you don't lose the reference to the application object, and that the exception handling always wraps around any other behaviour.","title":"Using ASGI middleware without Starlette"},{"location":"middleware/#basehttpmiddleware","text":"An abstract class that allows you to write ASGI middleware against a request/response interface, rather than dealing with ASGI messages directly. To implement a middleware class using BaseHTTPMiddleware , you must override the async def dispatch(request, call_next) method. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware ) If you want to provide configuration options to the middleware class you should override the __init__ method, ensuring that the first argument is app , and any remaining arguments are optional keyword arguments. Make sure to set the app attribute on the class if you do this. class CustomHeaderMiddleware ( BaseHTTPMiddleware ): def __init__ ( self , app , header_value = 'Example' ): self . app = app self . header_value async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom' ] = self . header_value return response app = Starlette () app . add_middleware ( CustomHeaderMiddleware , header_value = 'Customized' ) Middleware classes should not modify their state outside of the __init__ method. Instead you should keep any state local to the dispatch method, or pass it around explicitly, rather than mutating the middleware instance.","title":"BaseHTTPMiddleware"},{"location":"release-notes/","text":"0.6.3 Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]), @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints. 0.6.2 SessionMiddleware Added support for request.session , with SessionMiddleware . 0.6.1 BaseHTTPMiddleware Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware ) 0.6.0 request.path_params The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through. request.url_for() Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object. app.url_path_for() Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string. app.routes Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] . Route, WebSocketRoute, Mount The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Release Notes"},{"location":"release-notes/#063","text":"Support routing to methods. Ensure url_path_for works with Mount('/{some_path_params}'). Fix Router(default=) argument. Support repeated paths, like: @app.route(\"/\", methods=[\"GET\"]), @app.route(\"/\", methods=[\"POST\"]) Use the default ThreadPoolExecutor for all sync endpoints.","title":"0.6.3"},{"location":"release-notes/#062","text":"","title":"0.6.2"},{"location":"release-notes/#sessionmiddleware","text":"Added support for request.session , with SessionMiddleware .","title":"SessionMiddleware"},{"location":"release-notes/#061","text":"","title":"0.6.1"},{"location":"release-notes/#basehttpmiddleware","text":"Added support for BaseHTTPMiddleware , which provides a standard request/response interface over a regular ASGI middleware. This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly. from starlette.applications import Starlette from starlette.middleware.base import BaseHTTPMiddleware class CustomMiddleware ( BaseHTTPMiddleware ): async def dispatch ( self , request , call_next ): response = await call_next ( request ) response . headers [ 'Custom-Header' ] = 'Example' return response app = Starlette () app . add_middleware ( CustomMiddleware )","title":"BaseHTTPMiddleware"},{"location":"release-notes/#060","text":"","title":"0.6.0"},{"location":"release-notes/#requestpath_params","text":"The biggest change in 0.6 is that endpoint signatures are no longer: async def func ( request : Request , ** kwargs ) -> Response Instead we just use: async def func ( request : Request ) -> Response The path parameters are available on the request as request.path_params . This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through.","title":"request.path_params"},{"location":"release-notes/#requesturl_for","text":"Request and WebSocketSession now support URL reversing with request.url_for(name, **path_params) . This method returns a fully qualified URL instance. The URL instance is a string-like object.","title":"request.url_for()"},{"location":"release-notes/#appurl_path_for","text":"Applications now support URL path reversing with app.url_path_for(name, **path_params) . This method returns a URL instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string.","title":"app.url_path_for()"},{"location":"release-notes/#approutes","text":"Applications now support a .routes parameter, which returns a list of [Route|WebSocketRoute|Mount] .","title":"app.routes"},{"location":"release-notes/#route-websocketroute-mount","text":"The low level components to Router now match the @app.route() , @app.websocket_route() , and app.mount() signatures.","title":"Route, WebSocketRoute, Mount"},{"location":"requests/","text":"Starlette includes a Request class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly. Request Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive . Method The request method is accessed as request.method . URL The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type'] Query Parameters Headers are exposed as an immutable multi-dict. For example: request.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Cookies Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie') Body There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form(), or .json()` will raise an error.","title":"Requests"},{"location":"requests/#request","text":"Signature: Request(scope, receive=None) from starlette.requests import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive .","title":"Request"},{"location":"requests/#method","text":"The request method is accessed as request.method .","title":"Method"},{"location":"requests/#url","text":"The request URL is accessed as request.url . The property is a string-like object that exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme .","title":"URL"},{"location":"requests/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type']","title":"Headers"},{"location":"requests/#query-parameters","text":"Headers are exposed as an immutable multi-dict. For example: request.query_params['search']","title":"Query Parameters"},{"location":"requests/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"requests/#cookies","text":"Cookies are exposed as a regular dictionary interface. For example: request.cookies.get('mycookie')","title":"Cookies"},{"location":"requests/#body","text":"There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as form data or multipart: await request.form() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.requests import Request from starlette.responses import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() , .form(), or .json()` will raise an error.","title":"Body"},{"location":"responses/","text":"Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the send channel. Response Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send ) Set Cookie Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False) key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via Javascript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional Delete Cookie Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None) HTMLResponse Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send ) PlainTextResponse Takes some text or bytes and returns an plain text response. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) JSONResponse Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send ) UJSONResponse A JSON response class that uses the optimised ujson library for serialisation. Using ujson will result in faster JSON serialisation, but is also less careful than Python's built-in implementation in how it handles some edge-cases. In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint. from starlette.responses import UJSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = UJSONResponse ({ 'hello' : 'world' }) await response ( receive , send ) RedirectResponse Returns an HTTP redirect. Uses a 302 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) StreamingResponse Takes an async generator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send ) FileResponse Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( '/statics/favicon.ico' ) await response ( receive , send )","title":"Responses"},{"location":"responses/#response","text":"Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.responses import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send )","title":"Response"},{"location":"responses/#set-cookie","text":"Starlette provides a set_cookie method to allow you to set cookies on the response object. Signature: Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False) key - A string that will be the cookie's key. value - A string that will be the cookie's value. max_age - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of 0 will discard the cookie immediately. Optional expires - An integer that defines the number of seconds until the cookie expires. Optional path - A string that specifies the subset of routes to which the cookie will apply. Optional domain - A string that specifies the domain for which the cookie is valid. Optional secure - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. Optional httponly - A bool indicating that the cookie cannot be accessed via Javascript through Document.cookie property, the XMLHttpRequest or Request APIs. Optional","title":"Set Cookie"},{"location":"responses/#delete-cookie","text":"Conversly, Starlette also provides a delete_cookie method to manually expire a set cookie. Signature: Response.delete_cookie(key, path='/', domain=None)","title":"Delete Cookie"},{"location":"responses/#htmlresponse","text":"Takes some text or bytes and returns an HTML response. from starlette.responses import HTMLResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send )","title":"HTMLResponse"},{"location":"responses/#plaintextresponse","text":"Takes some text or bytes and returns an plain text response. from starlette.responses import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"PlainTextResponse"},{"location":"responses/#jsonresponse","text":"Takes some data and returns an application/json encoded response. from starlette.responses import JSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send )","title":"JSONResponse"},{"location":"responses/#ujsonresponse","text":"A JSON response class that uses the optimised ujson library for serialisation. Using ujson will result in faster JSON serialisation, but is also less careful than Python's built-in implementation in how it handles some edge-cases. In general you probably want to stick with JSONResponse by default unless you are micro-optimising a particular endpoint. from starlette.responses import UJSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = UJSONResponse ({ 'hello' : 'world' }) await response ( receive , send )","title":"UJSONResponse"},{"location":"responses/#redirectresponse","text":"Returns an HTTP redirect. Uses a 302 status code by default. from starlette.responses import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"RedirectResponse"},{"location":"responses/#streamingresponse","text":"Takes an async generator and streams the response body. from starlette.responses import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send )","title":"StreamingResponse"},{"location":"responses/#fileresponse","text":"Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.responses import FileResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( '/statics/favicon.ico' ) await response ( receive , send )","title":"FileResponse"},{"location":"routing/","text":"Starlette includes a Router class which is an ASGI application that dispatches incoming requests to endpoints or submounted applications. from starlette.routing import Mount , Route , Router from myproject import Homepage , SubMountedApp app = Router ([ Route ( '/' , endpoint = Homepage , methods = [ 'GET' ]), Mount ( '/mount' , app = SubMountedApp ) ]) Paths can use URI templating style to capture path components. Route ( '/users/{username}' , endpoint = User , methods = [ 'GET' ]) Path parameters are made available in the request, as the request.path_params dictionary. Because the target of a Mount is an ASGI instance itself, routers allow for easy composition. For example: app = Router ([ Route ( '/' , endpoint = Homepage , methods = [ 'GET' ]), Mount ( '/users' , app = Router ([ Route ( '/' , endpoint = Users , methods = [ 'GET' , 'POST' ]), Route ( '/{username}' , endpoint = User , methods = [ 'GET' ]), ])) ]) The router will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.","title":"Routing"},{"location":"staticfiles/","text":"Starlette also includes a StaticFiles class for serving a specific directory: StaticFiles(directory) - Serve any files in the given directory . You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving. from starlette.routing import Router , Mount from starlette.staticfiles import StaticFiles app = Router ( routes = [ Mount ( '/static' , app = StaticFiles ( directory = 'static' )), ]) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.","title":"Static Files"},{"location":"testclient/","text":"The test client allows you to make requests against your ASGI application, using the requests library. from starlette.responses import HTMLResponse from starlette.testclient import TestClient class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( receive , send ) def test_app (): client = TestClient ( App ) response = client . get ( '/' ) assert response . status_code == 200 The test client exposes the same interface as any other requests session. In particular, note that the calls to make a request are just standard function calls, not awaitables. You can use any of requests standard API, such as authentication, session cookies handling, or file uploads. By default the TestClient will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use client = TestClient(app, raise_server_exceptions=False) . Testing WebSocket sessions You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client. Establishing a test session .websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection. Sending data .send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data) - Send the given data to the application. Receiving data .receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json() - Wait for incoming json data sent by the application and return it. May raise starlette.websockets.Disconnect . Closing the connection .close(code=1000) - Perform a client-side close of the websocket connection.","title":"Test Client"},{"location":"testclient/#testing-websocket-sessions","text":"You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as websocket : data = websocket . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.","title":"Testing WebSocket sessions"},{"location":"testclient/#establishing-a-test-session","text":".websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection.","title":"Establishing a test session"},{"location":"testclient/#sending-data","text":".send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data) - Send the given data to the application.","title":"Sending data"},{"location":"testclient/#receiving-data","text":".receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json() - Wait for incoming json data sent by the application and return it. May raise starlette.websockets.Disconnect .","title":"Receiving data"},{"location":"testclient/#closing-the-connection","text":".close(code=1000) - Perform a client-side close of the websocket connection.","title":"Closing the connection"},{"location":"websockets/","text":"Starlette includes a WebSocket class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket. WebSocket Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path. URL The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version'] Query Parameters Headers are exposed as an immutable multi-dict. For example: websocket.query_params['search'] Path Parameters Router path parameters are exposed as a dictionary interface. For example: request.path_params['username'] Accepting the connection await websocket.accept(subprotocol=None) Sending data await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data) Receiving data await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.Disconnect() . Closing the connection await websocket.close(code=1000) Sending and receiving messages If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"WebSockets"},{"location":"websockets/#websocket","text":"Signature: WebSocket(scope, receive=None, send=None) from starlette.websockets import WebSocket class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): websocket = WebSocket ( self . scope , receive = receive , send = send ) await websocket . accept () await websocket . send_text ( 'Hello, world!' ) await websocket . close () WebSockets present a mapping interface, so you can use them in the same way as a scope . For instance: websocket['path'] will return the ASGI path.","title":"WebSocket"},{"location":"websockets/#url","text":"The websocket URL is accessed as websocket.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: websocket.url.path , websocket.url.port , websocket.url.scheme .","title":"URL"},{"location":"websockets/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: websocket.headers['sec-websocket-version']","title":"Headers"},{"location":"websockets/#query-parameters","text":"Headers are exposed as an immutable multi-dict. For example: websocket.query_params['search']","title":"Query Parameters"},{"location":"websockets/#path-parameters","text":"Router path parameters are exposed as a dictionary interface. For example: request.path_params['username']","title":"Path Parameters"},{"location":"websockets/#accepting-the-connection","text":"await websocket.accept(subprotocol=None)","title":"Accepting the connection"},{"location":"websockets/#sending-data","text":"await websocket.send_text(data) await websocket.send_bytes(data) await websocket.send_json(data)","title":"Sending data"},{"location":"websockets/#receiving-data","text":"await websocket.receive_text() await websocket.receive_bytes() await websocket.receive_json() May raise starlette.websockets.Disconnect() .","title":"Receiving data"},{"location":"websockets/#closing-the-connection","text":"await websocket.close(code=1000)","title":"Closing the connection"},{"location":"websockets/#sending-and-receiving-messages","text":"If you need to send or receive raw ASGI messages then you should use websocket.send() and websocket.receive() rather than using the raw send and receive callables. This will ensure that the websocket's state is kept correctly updated. await websocket.send(message) await websocket.receive()","title":"Sending and receiving messages"}]}