{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2728 The little ASGI library that shines. \u2728 Introduction Starlette is a small library for working with ASGI . It gives you Request and Response classes, request routing, websocket support, static files support, and a test client. Requirements Python 3.6+ Installation $ pip3 install starlette Example from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send ) You can run the application with any ASGI server, including uvicorn , daphne , or hypercorn . Install the Uvicorn ASGI server: $ pip3 install uvicorn [ ... ] Successfully installed uvicorn Run the App application in example.py : $ uvicorn run example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#introduction","text":"Starlette is a small library for working with ASGI . It gives you Request and Response classes, request routing, websocket support, static files support, and a test client.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install starlette","title":"Installation"},{"location":"#example","text":"from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send ) You can run the application with any ASGI server, including uvicorn , daphne , or hypercorn . Install the Uvicorn ASGI server: $ pip3 install uvicorn [ ... ] Successfully installed uvicorn Run the App application in example.py : $ uvicorn run example:App INFO: Started server process [ 11509 ] INFO: Uvicorn running on http://127.0.0.1:8000 ( Press CTRL+C to quit ) \u2014 \u2b50\ufe0f \u2014 Starlette is BSD licensed code. Designed & built in Brighton, England.","title":"Example"},{"location":"applications/","text":"Starlette also includes an App class that nicely ties together all of its other functionality. from starlette.app import App from starlette.response import PlainTextResponse from starlette.staticfiles import StaticFiles app = App () app . debug = True app . mount ( \"/static\" , StaticFiles ( directory = \"static\" )) @app.route ( '/' ) def homepage ( request ): return PlainTextResponse ( 'Hello, world!' ) @app.route ( '/user/{username}' ) def user ( request , username ): return PlainTextResponse ( 'Hello, %s !' % username ) @app.websocket_route ( '/ws' ) async def websocket_endpoint ( session ): await session . accept () await session . send_text ( 'Hello, websocket!' ) await session . close () Instantiating the application App(debug=False) - Create a new Starlette application. Adding routes to the application You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style. Submounting other applications Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix Customizing exception handling You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Applications"},{"location":"applications/#instantiating-the-application","text":"App(debug=False) - Create a new Starlette application.","title":"Instantiating the application"},{"location":"applications/#adding-routes-to-the-application","text":"You can use any of the following to add handled routes to the application: app.add_route(path, func, methods=[\"GET\"]) - Add an HTTP route. The function may be either a coroutine or a regular function, with a signature like func(request, **kwargs) -> response . app.add_websocket_route(path, func) - Add a websocket session route. The function must be a coroutine, with a signature like func(session, **kwargs) . @app.route(path) - Add an HTTP route, decorator style. @app.websocket_route(path) - Add a WebSocket route, decorator style.","title":"Adding routes to the application"},{"location":"applications/#submounting-other-applications","text":"Submounting applications is a powerful way to include reusable ASGI applications. app.mount(prefix, app) - Include an ASGI app, mounted under the given path prefix","title":"Submounting other applications"},{"location":"applications/#customizing-exception-handling","text":"You can use either of the following to catch and handle particular types of exceptions that occur within the application: app.add_exception_handler(exc_class, handler) - Add an error handler. The handler function may be either a coroutine or a regular function, with a signature like func(request, exc) -> response . @app.exception_handler(exc_class) - Add an error handler, decorator style. app.debug - Enable or disable error tracebacks in the browser.","title":"Customizing exception handling"},{"location":"debugging/","text":"You can use Starlette's DebugMiddleware to display simple error tracebacks in the browser. from starlette.debug import DebugMiddleware class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): raise RuntimeError ( 'Something went wrong' ) app = DebugMiddleware ( App ) For a mode complete handling of exception cases you may wish to use Starlette's ExceptionMiddleware class instead, which also includes optional debug handling.","title":"Debugging"},{"location":"exceptions/","text":"Starlette includes an exception handling middleware that you can use in order to dispatch different classes of exceptions to different handlers. To see how this works, we'll start by with this small ASGI application: from starlette.exceptions import ExceptionMiddleware , HTTPException class App : def __init__ ( self , scope ): raise HTTPException ( status_code = 403 ) app = ExceptionMiddleware ( App ) If you run the app and make an HTTP request to it, you'll get a plain text response with a \"403 Permission Denied\" response. This is the behaviour that the default handler responds with when an HTTPException class or subclass is raised. Let's change the exception handling, so that we get JSON error responses instead: from starlette.exceptions import ExceptionMiddleware , HTTPException from starlette.response import JSONResponse class App : def __init__ ( self , scope ): raise HTTPException ( status_code = 403 ) def handler ( request , exc ): return JSONResponse ({ \"detail\" : exc . detail }, status_code = exc . status_code ) app = ExceptionMiddleware ( App ) app . add_exception_handler ( HTTPException , handler ) Now if we make a request to the application, we'll get back a JSON encoded HTTP response. By default two types of exceptions are caught and dealt with: HTTPException - Used to raise standard HTTP error codes. Exception - Used as a catch-all handler to deal with any 500 Internal Server Error responses. The Exception case also wraps any other exception handling. The catch-all Exception case is used to return simple 500 Internal Server Error responses. During development you might want to switch the behaviour so that it displays an error traceback in the browser: app = ExceptionMiddleware(App, debug=True) This uses the same error tracebacks as the more minimal DebugMiddleware . The exception handler currently only catches and deals with exceptions within HTTP requests. Any websocket exceptions will simply be raised to the server and result in an error log. ExceptionMiddleware The exception middleware catches and handles the exceptions, returning appropriate HTTP responses. ExceptionMiddleware(app, debug=False) - Instantiate the exception handler, wrapping up it around an inner ASGI application. Adding handlers: .add_exception_handler(exc_class, handler) - Set a handler function to run for the given exception class. Enabling debug mode: .debug - If set to True , then the catch-all handler for Exception will not be used, and error tracebacks will be sent as responses instead. HTTPException The HTTPException class provides a base class that you can use for any standard HTTP error conditions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None)","title":"Exceptions"},{"location":"exceptions/#exceptionmiddleware","text":"The exception middleware catches and handles the exceptions, returning appropriate HTTP responses. ExceptionMiddleware(app, debug=False) - Instantiate the exception handler, wrapping up it around an inner ASGI application. Adding handlers: .add_exception_handler(exc_class, handler) - Set a handler function to run for the given exception class. Enabling debug mode: .debug - If set to True , then the catch-all handler for Exception will not be used, and error tracebacks will be sent as responses instead.","title":"ExceptionMiddleware"},{"location":"exceptions/#httpexception","text":"The HTTPException class provides a base class that you can use for any standard HTTP error conditions. The ExceptionMiddleware implementation defaults to returning plain-text HTTP responses for any HTTPException . HTTPException(status_code, detail=None)","title":"HTTPException"},{"location":"requests/","text":"Starlette includes a Request class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly. Request Signature: Request(scope, receive=None) from starlette.request import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive . Method The request method is accessed as request.method . URL The request URL is accessed as request.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type'] Query Parameters Headers are exposed as an immutable multi-dict. For example: request.query_params['abc'] Body There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.request import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() and .json() will raise an error.","title":"Requests"},{"location":"requests/#request","text":"Signature: Request(scope, receive=None) from starlette.request import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) content = ' %s %s ' % ( request . method , request . url . path ) response = Response ( content , media_type = 'text/plain' ) await response ( receive , send ) Requests present a mapping interface, so you can use them in the same way as a scope . For instance: request['path'] will return the ASGI path. If you don't need to access the request body you can instantiate a request without providing an argument to receive .","title":"Request"},{"location":"requests/#method","text":"The request method is accessed as request.method .","title":"Method"},{"location":"requests/#url","text":"The request URL is accessed as request.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: request.url.path , request.url.port , request.url.scheme .","title":"URL"},{"location":"requests/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: request.headers['content-type']","title":"Headers"},{"location":"requests/#query-parameters","text":"Headers are exposed as an immutable multi-dict. For example: request.query_params['abc']","title":"Query Parameters"},{"location":"requests/#body","text":"There are a few different interfaces for returning the body of the request: The request body as bytes: await request.body() The request body, parsed as JSON: await request.json() You can also access the request body as a stream, using the async for syntax: from starlette.request import Request from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): request = Request ( self . scope , receive ) body = b '' async for chunk in request . stream (): body += chunk response = Response ( body , media_type = 'text/plain' ) await response ( receive , send ) If you access .stream() then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to .body() and .json() will raise an error.","title":"Body"},{"location":"responses/","text":"Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the send channel. Response Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send ) HTMLResponse Takes some text or bytes and returns an HTML response. from starlette.response import HTMLResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send ) PlainTextResponse Takes some text or bytes and returns an plain text response. from starlette.response import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) JSONResponse Takes some data and returns an application/json encoded response. from starlette.response import JSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send ) RedirectResponse Returns an HTTP redirect. Uses a 302 status code by default. from starlette.response import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send ) StreamingResponse Takes an async generator and streams the response body. from starlette.response import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send ) FileResponse Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.response import FileResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( '/statics/favicon.ico' ) await response ( receive , send )","title":"Responses"},{"location":"responses/#response","text":"Signature: Response(content, status_code=200, headers=None, media_type=None) content - A string or bytestring. status_code - An integer HTTP status code. headers - A dictionary of strings. media_type - A string giving the media type. eg. \"text/html\" Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. Once you've instantiated a response, you can send it by calling it as an ASGI application instance. from starlette.response import Response class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = Response ( 'Hello, world!' , media_type = 'text/plain' ) await response ( receive , send )","title":"Response"},{"location":"responses/#htmlresponse","text":"Takes some text or bytes and returns an HTML response. from starlette.response import HTMLResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body><h1>Hello, world!</h1></body></html>' ) await response ( receive , send )","title":"HTMLResponse"},{"location":"responses/#plaintextresponse","text":"Takes some text or bytes and returns an plain text response. from starlette.response import PlainTextResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"PlainTextResponse"},{"location":"responses/#jsonresponse","text":"Takes some data and returns an application/json encoded response. from starlette.response import JSONResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = JSONResponse ({ 'hello' : 'world' }) await response ( receive , send )","title":"JSONResponse"},{"location":"responses/#redirectresponse","text":"Returns an HTTP redirect. Uses a 302 status code by default. from starlette.response import PlainTextResponse , RedirectResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): if self . scope [ 'path' ] != '/' : response = RedirectResponse ( url = '/' ) else : response = PlainTextResponse ( 'Hello, world!' ) await response ( receive , send )","title":"RedirectResponse"},{"location":"responses/#streamingresponse","text":"Takes an async generator and streams the response body. from starlette.response import StreamingResponse import asyncio async def slow_numbers ( minimum , maximum ): yield ( '<html><body><ul>' ) for number in range ( minimum , maximum + 1 ): yield '<li> %d </li>' % number await asyncio . sleep ( 0.5 ) yield ( '</ul></body></html>' ) class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): generator = slow_numbers ( 1 , 10 ) response = StreamingResponse ( generator , media_type = 'text/html' ) await response ( receive , send )","title":"StreamingResponse"},{"location":"responses/#fileresponse","text":"Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition . File responses will include appropriate Content-Length , Last-Modified and ETag headers. from starlette.response import FileResponse class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = FileResponse ( '/statics/favicon.ico' ) await response ( receive , send )","title":"FileResponse"},{"location":"routing/","text":"Starlette includes a Router class which is an ASGI application that dispatches to other ASGI applications. from starlette.routing import Router , Path , PathPrefix from myproject import Homepage , SubMountedApp app = Router ([ Path ( '/' , app = Homepage , methods = [ 'GET' ]), PathPrefix ( '/mount/' , app = SubMountedApp ) ]) Paths can use URI templating style to capture path components. Path ( '/users/{username}' , app = User , methods = [ 'GET' ]) Path components are made available in the scope, as scope[\"kwargs\"] . You can also use regular expressions for more complicated matching. Named capture groups will be included in scope[\"kwargs\"] : Path ( '/users/(?P<username>[a-zA-Z0-9_]{1,20})' , app = User , methods = [ 'GET' ]) Because each target of the router is an ASGI instance itself, routers allow for easy composition. For example: app = Router ([ Path ( '/' , app = Homepage , methods = [ 'GET' ]), PathPrefix ( '/users' , app = Router ([ Path ( '/' , app = Users , methods = [ 'GET' , 'POST' ]), Path ( '/{username}' , app = User , methods = [ 'GET' ]), ])) ]) The router will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. Protocol Routing You can also route based on the incoming protocol, using the ProtocolRouter class. from starlette.response import Response from starlette.routing import ProtocolRouter from starlette.websockets import WebSocketSession def http_endpoint ( scope ): return Response ( \"Hello, world\" , media_type = \"text/plain\" ) def websocket_endpoint ( scope ): async def asgi ( receive , send ): session = WebSocketSession ( scope , receive , send ) await session . accept () await session . send_json ({ \"hello\" : \"world\" }) await session . close () return asgi app = ProtocolRouter ({ \"http\" : http_endpoint , \"websocket\" : websocket_endpoint })","title":"Routing"},{"location":"routing/#protocol-routing","text":"You can also route based on the incoming protocol, using the ProtocolRouter class. from starlette.response import Response from starlette.routing import ProtocolRouter from starlette.websockets import WebSocketSession def http_endpoint ( scope ): return Response ( \"Hello, world\" , media_type = \"text/plain\" ) def websocket_endpoint ( scope ): async def asgi ( receive , send ): session = WebSocketSession ( scope , receive , send ) await session . accept () await session . send_json ({ \"hello\" : \"world\" }) await session . close () return asgi app = ProtocolRouter ({ \"http\" : http_endpoint , \"websocket\" : websocket_endpoint })","title":"Protocol Routing"},{"location":"staticfiles/","text":"As well as the FileResponse class, Starlette also includes ASGI applications for serving a specific file or directory: StaticFile(path) - Serve a single file, given by path . StaticFiles(directory) - Serve any files in the given directory . You can combine these ASGI applications with Starlette's routing to provide comprehensive static file serving. from starlette.routing import Router , Path , PathPrefix from starlette.staticfiles import StaticFile , StaticFiles app = Router ( routes = [ Path ( '/' , app = StaticFile ( path = 'index.html' )), PathPrefix ( '/static' , app = StaticFiles ( directory = 'static' )), ]) Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match.","title":"Static Files"},{"location":"test_client/","text":"The test client allows you to make requests against your ASGI application, using the requests library. from starlette.response import HTMLResponse from starlette.testclient import TestClient class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): response = HTMLResponse ( '<html><body>Hello, world!</body></html>' ) await response ( receive , send ) def test_app (): client = TestClient ( App ) response = client . get ( '/' ) assert response . status_code == 200 The test client exposes the same interface as any other requests session. In particular, note that the calls to make a request are just standard function calls, not awaitables. You can use any of requests standard API, such as authentication, session cookies handling, or file uploads. By default the TestClient will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use client = TestClient(app, raise_server_exceptions=False) . Testing WebSocket sessions You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocketSession class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): session = WebSocketSession ( self . scope , receive = receive , send = send ) await session . accept () await session . send_text ( 'Hello, world!' ) await session . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as session : data = session . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client. Establishing a test session .websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection. Sending data .send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data) - Send the given data to the application. Receiving data .receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json() - Wait for incoming json data sent by the application and return it. May raise starlette.websockets.Disconnect . Closing the connection .close(code=1000) - Perform a client-side close of the websocket connection.","title":"Test Client"},{"location":"test_client/#testing-websocket-sessions","text":"You can also test websocket sessions with the test client. The requests library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing. from starlette.testclient import TestClient from starlette.websockets import WebSocketSession class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): session = WebSocketSession ( self . scope , receive = receive , send = send ) await session . accept () await session . send_text ( 'Hello, world!' ) await session . close () def test_app (): client = TestClient ( App ) with client . websocket_connect ( '/' ) as session : data = session . receive_text () assert data == 'Hello, world!' The operations on session are standard function calls, not awaitables. It's important to use the session within a context-managed with block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.","title":"Testing WebSocket sessions"},{"location":"test_client/#establishing-a-test-session","text":".websocket_connect(url, subprotocols=None, **options) - Takes the same set of arguments as requests.get() . May raise starlette.websockets.Disconnect if the application does not accept the websocket connection.","title":"Establishing a test session"},{"location":"test_client/#sending-data","text":".send_text(data) - Send the given text to the application. .send_bytes(data) - Send the given bytes to the application. .send_json(data) - Send the given data to the application.","title":"Sending data"},{"location":"test_client/#receiving-data","text":".receive_text() - Wait for incoming text sent by the application and return it. .receive_bytes() - Wait for incoming bytestring sent by the application and return it. .receive_json() - Wait for incoming json data sent by the application and return it. May raise starlette.websockets.Disconnect .","title":"Receiving data"},{"location":"test_client/#closing-the-connection","text":".close(code=1000) - Perform a client-side close of the websocket connection.","title":"Closing the connection"},{"location":"views/","text":"Starlette includes a View class that provides a class-based view pattern which handles HTTP method dispatching. The View class can be used as an other ASGI application: from starlette.response import PlainTextResponse from starlette.views import View class App ( View ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) If you're using a Starlette application instance to handle routing, you can dispatch to a View class by using the @app.route() decorator, or the app.add_route() function. Make sure to dispatch to the class itself, rather than to an instance of the class: from starlette.app import App from starlette.response import PlainTextResponse from starlette.views import View app = App () @app.route ( \"/\" ) class Homepage ( View ): async def get ( self , request ): return PlainTextResponse ( f \"Hello, world!\" ) @app.route ( \"/{username}\" ) class User ( View ): async def get ( self , request , username ): return PlainTextResponse ( f \"Hello, {username}\" ) Class-based views will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.","title":"Views"},{"location":"websockets/","text":"Starlette includes a WebSocketSessions class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket session. WebSocketSession Signature: WebSocketSession(scope, receive=None, send=None) from starlette.websockets import WebSocketSession class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): session = WebSocketSession ( self . scope , receive = receive , send = send ) await session . accept () await session . send_text ( 'Hello, world!' ) await session . close () Sessions present a mapping interface, so you can use them in the same way as a scope . For instance: session['path'] will return the ASGI path. URL The session URL is accessed as session.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: session.url.path , session.url.port , session.url.scheme . Headers Headers are exposed as an immutable, case-insensitive, multi-dict. For example: session.headers['sec-websocket-version'] Query Parameters Headers are exposed as an immutable multi-dict. For example: session.query_params['abc'] Accepting the connection await session.accept(subprotocol=None) Sending data await session.send_text(data) await session.send_bytes(data) await session.send_json(data) Receiving data await session.receive_text() await session.receive_bytes() await session.receive_json() May raise starlette.websockets.Disconnect() . Closing the connection await session.close(code=1000) Sending and receiving messages If you need to send or receive raw ASGI messages then you should use session.send() and session.receive() rather than using the raw send and receive callables. This will ensure that the session's state is kept correctly updated. await session.send(message) await session.receive()","title":"WebSockets"},{"location":"websockets/#websocketsession","text":"Signature: WebSocketSession(scope, receive=None, send=None) from starlette.websockets import WebSocketSession class App : def __init__ ( self , scope ): self . scope = scope async def __call__ ( self , receive , send ): session = WebSocketSession ( self . scope , receive = receive , send = send ) await session . accept () await session . send_text ( 'Hello, world!' ) await session . close () Sessions present a mapping interface, so you can use them in the same way as a scope . For instance: session['path'] will return the ASGI path.","title":"WebSocketSession"},{"location":"websockets/#url","text":"The session URL is accessed as session.url . The property is actually a subclass of str , and also exposes all the components that can be parsed out of the URL. For example: session.url.path , session.url.port , session.url.scheme .","title":"URL"},{"location":"websockets/#headers","text":"Headers are exposed as an immutable, case-insensitive, multi-dict. For example: session.headers['sec-websocket-version']","title":"Headers"},{"location":"websockets/#query-parameters","text":"Headers are exposed as an immutable multi-dict. For example: session.query_params['abc']","title":"Query Parameters"},{"location":"websockets/#accepting-the-connection","text":"await session.accept(subprotocol=None)","title":"Accepting the connection"},{"location":"websockets/#sending-data","text":"await session.send_text(data) await session.send_bytes(data) await session.send_json(data)","title":"Sending data"},{"location":"websockets/#receiving-data","text":"await session.receive_text() await session.receive_bytes() await session.receive_json() May raise starlette.websockets.Disconnect() .","title":"Receiving data"},{"location":"websockets/#closing-the-connection","text":"await session.close(code=1000)","title":"Closing the connection"},{"location":"websockets/#sending-and-receiving-messages","text":"If you need to send or receive raw ASGI messages then you should use session.send() and session.receive() rather than using the raw send and receive callables. This will ensure that the session's state is kept correctly updated. await session.send(message) await session.receive()","title":"Sending and receiving messages"}]}